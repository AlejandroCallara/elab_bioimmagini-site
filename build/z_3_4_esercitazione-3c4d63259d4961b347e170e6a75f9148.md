# Esercitazione 6: segmentazione dell'albero bronchiale
## Contesto clinico
L’analisi dell’albero polmonare è importante in pazienti con insufficienza respiratoria, nei quali per varie patologie si può avere un restringimento del lume bronchiale o una stenosi dei tratti terminali dell’albero. In un soggetto normale le dimensioni delle varie componenti dell’albero sono quelle in Figura 3.69.

<img src="./images/image-69.png" alt="albero" style="width:100%;">

*Figura 3.69. Dimensione delle componenti dell'albero bronchiale per un soggetto sano.* 

Attraverso immagini CT ad alta risoluzione è possibile misurare nel singolo paziente la struttura e le dimensioni dell’albero e verificare la presenza di patologie (Figura 3.70). A questo scopo è necessario ricavare la struttura dell’albero per verificare la lunghezza dei vari tratti (seconda colonna della tabella) e misurare il diametro dei vari tratti (prima colonna della tabella).

<img src="./images/image-70.png" alt="segm-albero" style="width:100%;">

*Figura 3.70. Esempio di segmentazione dell'albero bronchiale.* 

Una demo di un software di questo tipo è visibile a https://www.youtube.com/watch?v=y0CB6Ko_QF4. 
Questo tipo di software si basa su operazioni di segmentazione dell’albero bronchiale e di estrazione della struttura dell’albero attraverso algoritmi di *skeletonization*.

## Esercitazione
L’esercitazione prevede lo sviluppo di una versione semplificata del software.
In particolare vogliamo ottenere due obiettivi:
1. Estrarre dall’immagine l’albero bronchiale (quindi il lume dei bronchi)
2. Misurare il diametro dell’albero scendendo lungo i bronchi.

Naturalmente faremo delle ipotesi semplificative rispetto alle tecniche effettivamente utilizzate nei software clinici. In particolare le immagini fornite coprono solo la prima biforcazione. 

La flow chart del software sarà costituita da una serie di blocchi come quelli riportati in Figura 3.71.

<img src="./images/image-71.png" alt="flowchart-segm-albero" style="width:100%;">

*Figura 3.71. Esempio di flowchart per la segmentazione dell'albero bronchiale.* 

Il set di dati utilizzato proviene dal Cancer Imaging Archive (https://www.cancerimagingarchive.net/), una repository di dati biomedici anonimizzati che possono essere utilizzati liberamente a scopi di ricerca. I dati sono “labellati” da operatori esperti e quindi possono anche costituire una base di conoscenza per la validazione di algoritmi di analisi dell’immagine. Nel nostro caso utilizziamo le immagini di un paziente dello studio LIDC-IDRI (https://wiki.cancerimagingarchive.net/pages/viewpage.action?pageId=1966254) dedicato all’identificazioni dei noduli polmonari. Nel nostro caso invece l’obiettivo è studiare l’albero bronchiale del paziente.
Il set di dati è una immagine 3D del torace composta da 148 slice ognuna memorizzata in un file DICOM. Rispetto al volume originale abbiamo la sezione che comprende solo la trachea e i bronchi. I dati DICOM sono memorizzati come numeri di Hounsfield, per cui per leggere correttamente i dati bisogna fare riferimento ai campi RescaleSlope ed RescaleIntercept che la funzione dicomread non utilizza correttamente.
Il volume, una volta caricato in un array, può essere visualizzato in MATLAB tramite la
funzione `sliceViewer`. In Python, una visualizzazione equivalente di un volume può essere effettuata utilizzando
viewer interattivi come **napari** (visualizzazione slice-by-slice lungo i diversi assi), oppure tramite strumenti di plotting come **matplotlib** per visualizzare singole slice.

Scorrendo le slides si individua nella prima la trachea (Figura 3.72), che esplorando il volume si suddivide nei due rami bronchiali principali. Il segnale all’interno dell’albero bronchiale è quello dell’aria quindi intorno al valore $H = -1000$.

<img src="./images/image-72.png" alt="trachea-bronchi" style="width:100%;">

*Figura 3.72. Trachea e rami bronchiali principale.* 

Il volume ottenuto caricando i dati DICOM in generale non sarà isotropo. E quindi necessario verificare se il volume è isotropo (voxel cubici) ed in caso contrario interpolarlo in modo da ottenere dei voxel cubici. L’interpolazione si effettua mantenendo costante il FOV dell’immagine (dimensione voxel x numero voxel nelle tre dimensioni). Tipicamente si pone la dimensione del voxel del volume interpolato pari alla dimensione del pixel (massima risoluzione). 

Volendo segmentare il lume dei bronchi, è ragionevole utilizzare un algoritmo di tipo region growing che parta da un seed da definire al livello della trachea. MATLAB non implementa l’algoritmo di *region growing* in 3D, per cui è necessario
implementare questa funzione. Come esempio si fornisce la funzione `regionGrowing3D`.
La funzione prende in ingresso l’immagine 3D, la tolleranza dell’algoritmo e il seed e
restituisce la maschera dell’oggetto segmentato. In Python, un’implementazione analoga del *region growing* 3D può essere realizzata
utilizzando funzioni della libreria **scikit-image**, ad esempio `skimage.segmentation.flood`,
che supporta dati multidimensionali. In questo caso, la funzione riceve in ingresso il
volume 3D, la tolleranza (criterio di similarità) e le coordinate del seed, e restituisce
la maschera binaria dell’oggetto segmentato.

Come si osserva la funzione utilizza come riferimento per il valore di segnale la media del segnale sulla segmentazione effettuata fino ad un certo punto del ciclo. L’intorno può essere definito come un cubo (26 connessioni) o una sfera (6 connessioni). È naturalmente possibile modificare la funzione per ottimizzare le prestazioni. La funzione è lenta (qualche minuto) quindi una volta effettuata la segmentazione è opportuno salvare la maschera in modo da poterla caricare per ottimizzare le operazioni seguenti. Il risultato dell’algoritmo di region growing sarà una maschera del tipo in Figura 3.73.

<img src="./images/image-73.png" alt="trachea-bronchi" style="width:100%;">

*Figura 3.73. Risultato dell'algoritmo region growing sull'albero bronchiale.* 

La maschera ottenuta deve essere raffinata attraverso l’uso di filtri che eliminino eventuali “buchi” dovuti alla mancata inclusione di alcuni voxel. Infatti, pixel di background spuri all’interno della maschera farebbero fallire l’algoritmo di skeletonization. La funzione `bwmorph3` di MATLAB implementa alcuni algoritmi di filtraggio morfologico,
tra cui le operazioni `'fill'` e `'majority'`, particolarmente adatte allo scopo.
In alternativa, è possibile eseguire un algoritmo di *labeling* sul background e
identificare i “buchi” nella maschera come tutti i blob eccetto quello di dimensione
maggiore. In Python, funzionalità analoghe possono essere ottenute utilizzando la libreria **SciPy**
e **scikit-image**. In particolare, un filtraggio di tipo *majority* può essere implementato
tramite la funzione `scipy.ndimage.generic_filter`, definendo opportunamente una funzione
di majority voting. Nella soluzione adottata, il filtraggio è stato realizzato utilizzando
`generic_filter` con `function=majority_filter`. Dove 
```python
def majority_filter(window):
    return 1 if np.sum(window) > (len(window) / 2) else 0
```

Ottenuta la maschera dell’albero bronchiale, la *centerline* può essere estratta tramite
un algoritmo di *skeletonization*. In MATLAB tale operazione è implementata dalla funzione
`bwskel`. Per ottenere uno scheletro più “pulito” è disponibile l’opzione
`MinBranchLength`, che consente di definire la lunghezza minima dei rami dello scheletro.
Lo scheletro risultante è simile a quello mostrato in figura e la funzione restituisce
una maschera binaria dei voxel appartenenti allo scheletro. In Python, un’operazione equivalente di *skeletonization* 3D può essere effettuata
utilizzando funzioni della libreria **scikit-image**, come `skimage.morphology.skeletonize`
(per dati binari) oppure `skimage.morphology.medial_axis`, che restituisce anche informazioni
sulla distanza dal contorno. La rimozione di rami corti (analoga a `MinBranchLength`)
può essere implementata tramite operazioni di *labeling* e filtraggio basato sulla lunghezza
dei rami dello scheletro.

Una volta ottenuto lo scheletro, in MATLAB la funzione `bwmorph3` consente di eseguire
ulteriori elaborazioni. Le opzioni `'clean'`, `'fill'` e `'remove'` permettono di
raffinare la forma dello scheletro, mentre l’opzione `'endpoints'` restituisce i punti
terminali dello scheletro. In Python, funzionalità analoghe possono essere realizzate
combinando operazioni di morfologia e *labeling* in **SciPy** e **scikit-image**; in
particolare, i punti terminali dello scheletro possono essere individuati analizzando
la connettività locale dei voxel scheletrici e utilizzati per identificare l’inizio e
la fine di un tratto dell’albero bronchiale.

Un esempio dello scheletro dell'albero ottenuto è in Figura 3.74.

<img src="./images/image-74.png" alt="skel" style="width:100%;">

*Figura 3.74. Scheletro.* 
 
Per la misura del diametro del lume si adopera il metodo della sfera (Figura 3.75), che viene utilizzato nella caratterizzazione di condotti cavi quali i vasi sanguigni. Nel metodo della sfera si considera il diametro del lume pari al diametro della massima sfera con centro situato nel centro di simmetria del vaso (nel nostro caso definito dallo scheletro) inscrivibile nel vaso stesso. In termini algoritmici la sfera è inscrivibile se tutti i suoi voxel appartengono alla maschera del lume.

<img src="./images/image-75.png" alt="metodo-sfera" style="width:100%;">

*Figura 3.75. Metodo della sfera.* 

L’algoritmo per ogni punto della ‘centerline’ prova ad inscrivere sfere di raggio via via maggiore fino a quando la sfera non oltrepassa la maschera del lume. A quel punto memorizza il diametro dell’ultima sfera inscritta. 

Definire la centerline su cui fare la misura per una struttura ramificata come l’albero bronchiale non è banale visto che il numero di percorsi possibili è alto. Di solito si utilizza un approccio simile a quello di Canny per la costruzione dei contorni dalle maschere in cui si tiene conto della distanza dei punti e della direzione di propagazione. Può essere utile la funzione strel che genera un kernel 3D di forma sferica. 

Nel nostro caso possiamo semplificare il problema partendo da un ramo terminale dello scheletro (coordinata z alta) ed andare ad includere punti dello scheletro andando a cercare in modo iterativo il punto più vicino e cancellando dalla lista i punti con valore della coordinata z minore di quella del punto inserito (Figura 3.76).

<img src="./images/image-76.png" alt="centerline" style="width:100%;">

*Figura 3.76. Stima della centerline.* 
 
La variazione del diametro lungo la centerline partendo dalla trachea dovrebbe risultare un grafico di questo tipo, con un diametro della trachea dell’ordine dei 15-18 mm ed un diametro dei bronchi primari dell’ordine dei 10-12 mm. Un possibile risultato è riportato in Figura 3.77. 

<img src="./images/image-77.png" alt="centerline" style="width:100%;">

*Figura 3.77. Risultato.* 